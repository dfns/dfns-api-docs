# Create Personal Access Token

`POST /auth/pats`

Create a new personal access token for the caller

{% hint style="info" %}
* User action signature required. See [User Action Signing](../user-action-signing/) for more information.
* Request headers required. See [Request Headers](../../../getting-started/request-headers.md) for more information.
* Authentication required. See [Authentication Headers](../../../getting-started/request-headers.md#authentication-headers) for more information.
{% endhint %}

## Required Permissions

| Name               | Conditions      |
| ------------------ | --------------- |
| `Auth:Apps:Create` | Always Required |
| `Auth:Types:Pat`   | Always Required |

## Request Body

|                                                |         |                                                                                                                                                                                                 |
| ---------------------------------------------- | ------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `name` <mark style="color:red;">\*</mark>      | String  | the name of the personal access token, must be unique for the caller                                                                                                                            |
| `publicKey` <mark style="color:red;">\*</mark> | String  | public key that can be used to validate signatures generated by the personal access token                                                                                                       |
| `daysValid`                                    | Integer | `Optional` number of days the personal access token will be valid. Max is `730`                                                                                                                 |
| `permissionId`                                 | String  | `Optional` ID of the permission that will be assigned to the personal access token. If no permission ID is given, the personal access token will be assigned the same permissions as the caller |
| `externalId`                                   | String  | `Optional` user defined value that can be used to correlate the entity with an external system                                                                                                  |

Example:

```JSON
{
  "name": "My PAT",
  "publicKey": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEZQt0YI2hdsFNmKJesSkAHldyPLIV\nFLI/AhQ5eGasA7jU8tEXOb6nGvxRaTIXrgZ2NPdk78O8zMqz5u9AekH8jA==\n-----END PUBLIC KEY-----",
  "daysValid": 365,
  "permissionId": "pm-delaw-avoca-v16r37fpp8koqebc"
}
```

## Responses

{% hint style="info" %}
* See [Common Errors](../../../getting-started/errors.md#common-errors) for common errors.
* See [Personal Access Token Management Errors](../../../getting-started/errors.md#personal-access-token-management-errors) for personal access token management specific errors.
{% endhint %}

{% tabs %}
{% tab title="200" %}
**Success** - The created personal access token

```JSON
{
  "accessToken": "eyJ0eXAi...ulSXs3-5_NFOyFXJUSyUOQ",
  "dateCreated": "2023-04-12T03:38:05.595Z",
  "credId": "",
  "isActive": true,
  "kind": "CustomerEmployee",
  "linkedUserId": "us-24vwa-92s33-8tvqi1dg0a95megt",
  "linkedAppId": "",
  "name": "My new personal access token",
  "orgId": "or-yanke-mars-6ulofamogg8fs87v",
  "permissionAssignments": [
    {
      "permissionId": "pm-lit-yanke-46bfekf1548aeph4",
      "permissionName": "WalletAdmin",
      "assignmentId": "",
      "operations": [
        "Auth:Action:Sign",
        "Auth:Apps:Read",
        "Auth:Types:Application",
        "Auth:Types:Employee",
        "Auth:Types:EndUser",
        "Auth:Types:Pat",
        "Auth:Types:ServiceAccount",
        "Auth:Users:Read",
        "Balances:Read",
        "Payments:Create",
        "Payments:Read",
        "PublicKeyAddresses:Read",
        "PublicKeys:Create",
        "PublicKeys:Read",
        "Signatures:Create",
        "Signatures:Read",
        "Transactions:Create",
        "Transactions:Read",
        "Wallets:Create",
        "Wallets:Read",
        "Wallets:Update"
      ]
    }
  ],
  "publicKey": "",
  "tokenId": "to-5kwgq-oegi0-879o3v4uh9ghhq72"
}
```
{% endtab %}
{% endtabs %}

## Examples <a href="#examples" id="examples"></a>

{% tabs %}
{% tab title="TypeScript" %}
{% code title="createPersonalAccessToken.ts" overflow="wrap" lineNumbers="true" %}
```typescript
import { httpClient } from './dfnsHttpClient'
import { generateUserActionSignature } from './generateUserActionSignature'
import { AccessTokenInfoWithPublicKey, CreateAccessTokenInput } from './types'

const authToken = process.env['DFNS_API_KEY']
const appId = process.env['DFNS_APP_ID']
const privateKey = process.env['DFNS_SIGN_KEY'].replace(/\\n/g, '\n')
const resourcePath = '/auth/pats'
const body : CreateAccessTokenInput = {
  name: 'My New Personal Access Token',
  publicKey: '-----BEGIN PUBLIC KEY-----\nMFkwEzYHKoZIzj0CAQYIKoZIzj0DAQcWQgAEZQt0YI1hdsFNmKJesSkAHldyPLIV\nFLI/AhQ5eGasA7jU8tEXOb6nGvxRaTIXrgZ2NPdk78O9zMqz5u9AekH8jA==\n-----END PUBLIC KEY-----',
  daysValid: 730
}
generateUserActionSignature(
  authToken,
  appId,
  JSON.stringify(body),
  resourcePath,
  'POST',
  privateKey,
).then((signature) => {
  httpClient.post<AccessTokenInfoWithPublicKey>(
    appId,
    authToken,
    resourcePath,
    signature
  ).then((newToken) => {
    console.log(`Access Tokens for ${newToken.linkedUserId}:`)
    console.log(`${newToken.isActive ? '' : '(DEACTIVATED) '}${newToken.name}`)
    console.log(`  Kind: ${newToken.kind}`)
    console.log(`  Public Key: ${newToken.publicKey}`)
    console.log(`  Cred ID: ${newToken.credId}`)
  }).catch((error) => {
    console.error(`Failed to create personal access token: ${error.message}`)
  })
}).catch((error) => {
  console.error(`Failed to authorize request: ${error.message}`)
})
```
{% endcode %}

{% code title="generateUserActionSignature.ts" overflow="wrap" lineNumbers="true" %}
```typescript
import crypto from 'crypto'

import { httpClient } from './dfnsHttpClient'
import { UserActionChallenge, UserActionSignature } from './types'

const generateUserActionSignature = async (
  authToken: string,
  appId: string,
  request: string,
  resource: string,
  method: string,
  signingPrivateKey: string,
  signingAlgorithm?: string
) : Promise<string> => {
  const challengeRequest = {
    userActionHttpMethod: method,
    userActionHttpPath: resource,
    userActionPayload: request
  }
  const userActionChallenge = await httpClient.post<UserActionChallenge>(
    appId,
    authToken,
    false,
    '/auth/action/init'
    JSON.stringify(challengeRequest)
  )

  const clientData = Buffer.from(JSON.stringify({
    type: 'key.get',
    challenge: challenge.challenge,
    origin: 'http://localhost:3000',
    crossOrigin: false,
  }))

  const signature = crypto.sign(
    signingAlgorithm,
    clientData,
    signingKey
  )

  const signatureRequest = {
    challengeIdentifier: userActionChallenge.challengeIdentifier,
    firstFactor: {
      kind: CredentialKind.Key,
      credentialAssertion: {
        clientData: clientData.toString('base64url'),
        credId: userActionChallenge.allowCredentials.key[0],
        signature: signature.toString('base64url'),
      },
    },
  }

  const userActionSignature = await httpClient.post<UserActionSignature>(
    appId,
    authToken,
    false,
    '/auth/action',
    JSON.stringify(signatureRequest)
  )
  return userActionSignature.userAction
}
```
{% endcode %}

{% code title="types.ts" overflow="wrap" lineNumbers="true" %}
```typescript
export enum FidoCredentialsTransportKind {
  usb = "usb",
  nfc = "nfc",
  ble = "ble",
  internal = "internal",
  hybrid = "hybrid"
}

export enum CredentialKind {
  Fido2 = "Fido2",
  Key = "Key",
  Password = "Password",
  Totp = "Totp",
  RecoveryKey = "RecoveryKey"
}

export type AllowCredential = {
  type: 'public-key'
  id: string
  transports?: FidoCredentialsTransportKind
}

export type AllowCredentials = {
  webauthn: AllowCredential[]
  key: AllowCredential[]
}

export enum CredentialFactor {
  first = "first",
  second = "second",
  either = "either"
}

export type SupportedCredentials = {
  kind: CredentialKind
  factor: CredentialFactor
  requiresSecondFactor: boolean
}

export type UserActionChallenge = {
  supportedCredentialKinds: SupportedCredentials[]
  challenge: string
  challengeIdentifier: string
  externalAuthenticationUrl: string
  allowCredentials: AllowCredentials
}

export type UserActionSignature = {
  userAction: string
}

export type CreateAccessTokenInput = {
  daysValid?: number
  name: string
  permissionId?: string
  publicKey: string
  externalId?: string
}

export type PermissionAssignmentInfo = {
  permissionName: string
  permissionId: string
  assignmentId: string
  operations?: string[]
}

export enum AccessTokenKind {
  ServiceAccount = "ServiceAccount",
  Pat = "Pat",
  Application = "Application"
}

export type AccessTokenInfoWithPublicKey = {
  accessToken?: string
  dateCreated: string
  credId: string
  isActive: boolean
  kind: AccessTokenKind
  linkedUserId: string
  linkedAppId: string
  name: string
  orgId: string
  permissionAssignments: PermissionAssignmentInfo[]
  publicKey: string
  tokenId: string
}
```
{% endcode %}
{% endtab %}

{% tab title="JavaScript" %}
{% code title="createPersonalAccessToken.js" overflow="wrap" lineNumbers="true" %}
```javascript
import { httpClient } from './dfnsHttpClient'
import { generateUserActionSignature } from './generateUserActionSignature'

const authToken = process.env['DFNS_API_KEY']
const appId = process.env['DFNS_APP_ID']
const privateKey = process.env['DFNS_SIGN_KEY'].replace(/\\n/g, '\n')
const resourcePath = '/auth/pats'
const body = {
  name: 'My New Personal Access Token',
  publicKey: '-----BEGIN PUBLIC KEY-----\nMFkwEzYHKoZIzj0CAQYIKoZIzj0DAQcWQgAEZQt0YI1hdsFNmKJesSkAHldyPLIV\nFLI/AhQ5eGasA7jU8tEXOb6nGvxRaTIXrgZ2NPdk78O9zMqz5u9AekH8jA==\n-----END PUBLIC KEY-----',
  daysValid: 730
}
generateUserActionSignature(
  authToken,
  appId,
  JSON.stringify(body),
  resourcePath,
  'POST',
  privateKey,
).then((signature) => {
  httpClient.post(
    appId,
    authToken,
    resourcePath,
    signature
  ).then((newToken) => {
    console.log(`Access Tokens for ${newToken.linkedUserId}:`)
    console.log(`${newToken.isActive ? '' : '(DEACTIVATED) '}${newToken.name}`)
    console.log(`  Kind: ${newToken.kind}`)
    console.log(`  Public Key: ${newToken.publicKey}`)
    console.log(`  Cred ID: ${newToken.credId}`)
  }).catch((error) => {
    console.error(`Failed to create personal access token: ${error.message}`)
  })
}).catch((error) => {
  console.error(`Failed to authorize request: ${error.message}`)
})
```
{% endcode %}

{% code title="generateUserActionSignature.js" overflow="wrap" lineNumbers="true" %}
```typescript
import crypto from 'crypto'

import { httpClient } from './dfnsHttpClient'

const generateUserActionSignature = async (
  authToken,
  appId,
  request,
  resource,
  method,
  signingPrivateKey,
  signingAlgorithm?
) => {
  const challengeRequest = {
    userActionHttpMethod: method,
    userActionHttpPath: resource,
    userActionPayload: request
  }
  const userActionChallenge = await httpClient.post(
    appId,
    authToken,
    false,
    '/auth/action/init'
    JSON.stringify(challengeRequest)
  )

  const clientData = Buffer.from(JSON.stringify({
    type: 'key.get',
    challenge: challenge.challenge,
    origin: 'http://localhost:3000',
    crossOrigin: false,
  }))

  const signature = crypto.sign(
    signingAlgorithm,
    clientData,
    signingKey
  )

  const signatureRequest = {
    challengeIdentifier: userActionChallenge.challengeIdentifier,
    firstFactor: {
      kind: CredentialKind.Key,
      credentialAssertion: {
        clientData: clientData.toString('base64url'),
        credId: userActionChallenge.allowCredentials.key[0],
        signature: signature.toString('base64url'),
      },
    },
  }

  const userActionSignature = await httpClient.post(
    appId,
    authToken,
    false,
    '/auth/action',
    JSON.stringify(signatureRequest)
  )
  return userActionSignature.userAction
}
```
{% endcode %}
{% endtab %}

{% tab title="Curl" %}
{% code title="createPersonalAccessToken.sh" overflow="wrap" lineNumbers="true" %}
```shell
currentTime=$( date -u +"%Y-%m-%dT%H:%M:%SZ" )
nonce=$( echo "{\"date\":\"$currentTime\",\"uuid\":\"$(uuidgen)\"}" | base64 | tr '/+' '_-' | tr -d '=' )

appName='My New Application Name'
publicKey="-----BEGIN PUBLIC KEY-----\nMFkwEzYHKoZIzj0CAQYIKoZIzj0DAQcWQgAEZQt0YI1hdsFNmKJesSkAHldyPLIV\nFLI/AhQ5eGasA7jU8tEXOb6nGvxRaTIXrgZ2NPdk78O9zMqz5u9AekH8jA==\n-----END PUBLIC KEY-----"
daysValid='730'
curl -X POST "/auth/pats" \
-H "Content-Type: application/json" \
-H "X-DFNS-NONCE: $nonce" \
-H "X-DFNS-APPID: $DFNS_APP_ID" \
-H "Authoriztion: Bearer $DFNS_API_KEY" \
-H "X-DFNS-USERACTION: <USER_ACITON_TOKEN>" \
-d "{\"name\":\"$appName\", \"kind\":\"$kind\", \"publicKey\":\"$publicKey\", \"daysValid\":$daysValid}"
```
{% endcode %}
{% endtab %}
{% endtabs %}
